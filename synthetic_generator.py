import sys
import math
import numpy as np
from matplotlib import pyplot as plt

def euclidean_distance(p1, p2):

	return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5


def divide_fairly(main, nummain, numgroups, numunities):

	groups_unities = []
	remainder_counter = 0

	for i in range(numgroups):
		max_nunities = int(math.floor(numunities * nummain))	
		
		if i == main:
			nunities = max_nunities
			
		else:
			left = numunities - max_nunities
			nunities = left / (numgroups - 1)
			
			# account for not multiples
			if nunities * (numgroups - 1) < left:
				remainder = left - nunities * (numgroups - 1)
				
				if remainder_counter < remainder:
					nunities += 1
					remainder_counter += 1

		groups_unities.append(nunities)

	return groups_unities
		

def get_nearest_cloud(representatives, index, length, height):

	# detect cloud nearest to other clusters
	origin = [0, 0]
	topright = [length, height]
	mindist = euclidean_distance(origin, topright) # max dist
	nearest_cloud = 0

	for i in range(len(representatives)):

		if i != index:

			for cloud1 in representatives[i]:

				for cloud2 in range(len(representatives[index])):
					dist = euclidean_distance(cloud1, 
											  representatives[index][cloud2])

					if dist < mindist:
						mindist = dist
						nearest_cloud = cloud2
						
	return nearest_cloud


def generate_point(origin, topright, mean, cov, distr):

	newpoint = [x - 1 for x in origin]

	if distr == 'uniform':
		newpoint = np.random.uniform(origin, topright).tolist()
				
	else:

		while newpoint[0] < origin[0] or newpoint[0] > topright[0] \
			  or newpoint[1] < origin[1] or newpoint[1] > topright[1]:
			newpoint = np.random.multivariate_normal(mean, cov).tolist()

	return newpoint


def generate_entity(representatives, index, noise, cloud_balance, 
					numpoints, delta, length, height):
				
	"""
	"""
	points = []
	origin = [0, 0]
	topright = [length, height]
	cloud_index = get_nearest_cloud(representatives, index, length, height)
	curr_representative = representatives[index]
	numclouds = len(curr_representative)
	total_noise = int(math.floor(numpoints * noise))

	npoints = divide_fairly(cloud_index, cloud_balance, numclouds, numpoints)
	nnoise = divide_fairly(cloud_index, cloud_balance, numclouds, total_noise)
	
	points_distr = []

	for i in range(numclouds):
		mean = curr_representative[i]
		cov = [[delta, 0], [0, delta]]

		for j in range(npoints[i]):

			if j < nnoise[i]:  # noise
				newpoint = generate_point(origin, topright, mean, cov, 
									  'uniform')
				points_distr.append(-1)  # mark as noise
				
			else:   # generated by cloud
				newpoint = generate_point(origin, topright, mean, cov, 
						   				  'gaussian')	
				points_distr.append(i)  # mark the corresponding cloud
				
			points.append(newpoint)

	return points, points_distr

		
def generate_entities(representatives, noise, cluster_balance, cloud_balance, 
					  numentities, numpoints, delta, length, height):
	"""
	"""			  
	numclusters = len(representatives)
	clusters = [[] for x in range(numclusters)]
	main_cluster = 0

	nentities = divide_fairly(main_cluster, cluster_balance, 
							  numclusters, numentities)
	
	for i in range(numclusters):
		curr_nentities = nentities[i]
					
		for j in range(curr_nentities):
			new_entity, entity_distr = generate_entity(representatives, i, 
													   noise, cloud_balance, 
													   numpoints, delta,
													   length, height)
			clusters[i].append(new_entity)
				
	return clusters


def generate_clouds(representatives, numclouds, cluster_distance, delta, 
					length, height):						
						
	"""
	"""
	origin = [0, 0]
	topright = [length, height]
	
	sample_new = True
	
	while sample_new:
		newrepresentative = []
		
		for i in range(numclouds):
			newcloud = np.random.uniform(origin, topright).tolist()
			newrepresentative.append(newcloud)
		
		#if len(representatives) == 2:
		#	newrepresentative[:] = representatives[1]
			
		sample_new = False

		for r in range(len(representatives)):
			dist_max = 0
	
			for cloud1 in range(numclouds):
				dist_min = euclidean_distance(origin, topright)
		
				for cloud2 in range(len(representatives[r])):
					curr_dist = euclidean_distance(newrepresentative[cloud1], 
												   representatives[r][cloud2])
												   
					if curr_dist < dist_min:
						dist_min = curr_dist
						
				if dist_min > dist_max:
					dist_max = dist_min

			if dist_max < cluster_distance * delta:
				sample_new = True
				print dist_max, len(representatives), 'repeat'
				break
				
			else:
				print dist_max, len(representatives)
				
	return newrepresentative


def generate_representatives(numclusters, numclouds, noise, cluster_distance, 
							 delta, length, height):

	representatives = []
	
	for i in range(numclusters):
		new_representative = generate_clouds(representatives, numclouds, 
											 cluster_distance, delta, length, 
											 height)
		representatives.append(new_representative)

	return representatives
	
	
def print_entities(clusters, outfile_name):

	with open(outfile_name, 'w') as outfile:
		count = 1
		
		for i in range(len(clusters)):
		
			for entity in clusters[i]:
			
				for point in entity:
					print >> outfile, "%f\t%f\t%d\t%d" % \
									  (point[0], point[1], count, i)
				
				count += 1


def plot_data(clusters, plot_name, length, height):

	fig = plt.figure()
	origin = [0, 0]
	topright = [length, height]

	colors = ['black', 'blue', 'yellow', 'red', 'green', 'gray', 
			  'pink', 'orange', 'brown', 'purple']

	for i in range(len(clusters)):
		x = []
		y = []
	
		for j in range(len(clusters[i])):
			x += [p[0] for p in clusters[i][j]]
			y += [p[1] for p in clusters[i][j]]
			
		plt.scatter(x, y, marker='.', facecolors=colors[i], s=2)
		plt.xlim(origin[0], topright[0])
		plt.ylim(origin[1], topright[1])

	plt.savefig(plot_name)


if __name__ == '__main__':

	numclusters = int(sys.argv[1])
	numclouds = int(sys.argv[2])
	noise = float(sys.argv[3])  # % points that are placed randomly
	cluster_balance = float(sys.argv[4])  # % entities in the main cluster
	cloud_balance = float(sys.argv[5])  # % points in the main cloud
	cluster_distance = float(sys.argv[6])
	seed = int(sys.argv[7])
	numentities = int(sys.argv[8])
	numpoints = int(sys.argv[9])
	delta = float(sys.argv[10])
	length = float(sys.argv[11])
	height = float(sys.argv[12])
	outfile_name = sys.argv[13]

	np.random.seed(seed)
	
	representatives = generate_representatives(numclusters, numclouds, noise, 
											   cluster_distance, delta, 
											   length, height)
	
	clusters = generate_entities(representatives, noise, cluster_balance, 
								 cloud_balance, numentities, numpoints, 
								 delta, length, height)
					  			 
	print_entities(clusters, outfile_name)
	plot_data(clusters, outfile_name + '_plot', length, height)
	
